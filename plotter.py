def plot_probs(legend, piesizes, title, fignum, concentrations, conc):
    plt.figure(fignum)
    plt.subplot(1, len(concentrations), concentrations.index(conc)+1)
    if conc != concentrations[-1]:
        plt.pie(piesizes, labels=None)
    else:
        plt.pie(piesizes, labels=legend)
        plt.legend(bbox_to_anchor=(1.05, 0), loc='lower left', borderaxespad=0.,prop={'size':10})
    plt.xlabel('$N_{BuOH}=%s$'%conc)
    plt.suptitle(title, fontsize=24)

def plot_biasing_potentials(fignum, concentrations, conc, etoh_bias_old, buoh_bias_old, etoh_bias_new_vapor, buoh_bias_new):
    plt.figure(fignum)
    ax1 = plt.subplot(1,len(concentrations), concentrations.index(conc) + 1)
    n_bias = 2 #number of biasing potentials monitoring
    old_bias = (etoh_bias_old, buoh_bias_old) #(old, new)
    new_bias = (etoh_bias_new_vapor, buoh_bias_new)
    #fig, ax = plt.subplots()
    index = np.arange(n_bias)
    bar_width = 0.35
    opacity = 0.4
    ax1.bar(index , old_bias, bar_width,
                     alpha=opacity,
                     color='b',
                     label='OLD')
    ax1.bar(index + bar_width, new_bias, bar_width,
                     alpha=opacity,
                     color='r',
                     label='NEW')
    plt.axis('on')
    ax1.set_xticklabels([])
    if conc == concentrations[-1]: plt.legend()



def vtkStructuredGrid(file_name, binSizes, binnedData):
    v = open(file_name,'w')
    v.write('# vtk DataFile Version 3.0\n')
    v.write('Generated by Rob DeJaco Python3\n')
    v.write('ASCII\n')
    v.write('DATASET STRUCTURED_POINTS\n')
    (NX, NY, NZ) = (len(binnedData[:,0,0]), len(binnedData[0,:,0]), len(binnedData[0,0,:]))
    v.write('DIMENSIONS %i %i %i\n' % (NX, NY, NZ) )
    v.write('ORIGIN 0 0 0\n')
    v.write('SPACING %f %f %f\n' %(binSizes[0], binSizes[1], binSizes[2]) )
    v.write('POINT_DATA %i\n' % (NX*NY*NZ) )
    v.write('SCALARS zonal int\n')
    v.write('LOOKUP_TABLE default\n') # I think default refers to color scheme
    num_pts = 0
    # x index varies the fastest
    for k in range(len(binnedData[0,0,:])):
        for j in range(len(binnedData[0,:,0])):
            for i in range(len(binnedData[:,0,0])):
                v.write('%i ' % binnedData[i, j, k])
                num_pts += 1
                if (num_pts % 8) == 0: v.write('\n')
    v.close()

def emFormat(file_name, binSizes, binnedData):
    v = open(file_name,'w')
    (NX, NY, NZ) = (len(binnedData[:,0,0]), len(binnedData[0,:,0]), len(binnedData[0,0,:]))
    v.write('                   %i      %i      %i\n' % (NX, NY, NZ) )
    # x index varies the fastest
    ptCoords = [ -edge/2 for edge in binSizes ]
    for nz in range(len(binnedData[0,0,:])):
        ptCoords[2] += binSizes[2]
        ptCoords[1] = -binSizes[1]/2 # restart y count
        for ny in range(len(binnedData[0,:,0])):
            ptCoords[1] += binSizes[1]
            ptCoords[0] = -binSizes[0]/2 # restart x count
            for nx in range(len(binnedData[:,0,0])):
                ptCoords[0] += binSizes[0]
                v.write('%i  %i  %i  %6.4f  %6.4f   %6.4f   %e\n' %
                         (nx, ny, nz, ptCoords[0], ptCoords[1], ptCoords[2], binnedData[nx, ny, nz]) )
    v.close()

def formatAxis(my_ax, x, y, xlabel, ylabel):

    my_ax.set_xlabel(xlabel,fontdict=font)
    my_ax.set_ylabel(ylabel,fontdict=font)
    x_min, y_min, x_max, y_max = min(x), min(y), max(x), max(y)
    # set y ticks
    y_nticks = 9 #int(y_max - y_min)
    y_ticks = [(y_max-y_min)/y_nticks*i + y_min for i in range(y_nticks + 1)]
    my_ax.set_yticks(y_ticks)
    y_minor = [(y_ticks[i] + y_ticks[i+1])/2. for i in range(y_nticks)]
    my_ax.set_yticks(y_minor,minor=True)
    my_ax.tick_params(axis='y',direction='out',which='both',labelsize=14,left=True,right=True)
    my_ax.set_ylim([y_min,y_max])
    # set x ticks
    x_nticks = 5 #int(x_max - x_min)
    x_ticks = [(x_max-x_min)/x_nticks*i + x_min for i in range(x_nticks + 1)]
    my_ax.set_xticks(x_ticks)
    my_ax.tick_params(axis='x',direction='out',which='both',labelsize=14,bottom=True,top=True)
    x_minor = [(x_ticks[i] + x_ticks[i+1])/2. for i in range(x_nticks)]
    my_ax.set_xticks(x_minor, minor=True)
    my_ax.set_xlim([x_min,x_max])

def heatmap(x,y,z, labels):
    xlabel, ylabel, zlabel, name = labels

    fig= plt.figure()
    ax = fig.add_subplot(111)
    image = ax.scatter(x,y,c=z,marker='s',cmap='viridis')
    formatAxis(ax, x,y,xlabel,ylabel)
    cbar =fig.colorbar(image, orientation='horizontal',pad=0.13)#,fraction = 0.046)
    cbar.set_label(zlabel,fontdict=font)
    cbar.ax.tick_params(labelsize=14)

    plt.subplots_adjust(left=0.15,right=0.96,top = 0.98, bottom=0.01,
                        hspace=0.5, wspace=0.8)
    fig.set_size_inches(5.0, 5.0)
    fig.savefig('%s.pdf'%name, dpi=600)

import matplotlib.pyplot as plt 
import numpy as np

font = {  'size': 18
    # 'weight':'bold',
    # 'style':'italic'
    }
from matplotlib import rc
rc('font',**{'family':'sans-serif','sans-serif':['Helvetica']})
## for Palatino and other serif fonts use:
#rc('font',**{'family':'serif','serif':['Palatino']})
rc('text', usetex=True)
